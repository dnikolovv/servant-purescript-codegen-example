-- File auto generated by purescript-bridge! --
module GenTypesDemo.API.Types where

import Prelude

import Control.Lazy (defer)
import Data.Argonaut (encodeJson, jsonNull)
import Data.Argonaut.Decode (class DecodeJson)
import Data.Argonaut.Decode.Aeson ((</$\>), (</*\>), (</\>))
import Data.Argonaut.Encode (class EncodeJson)
import Data.Argonaut.Encode.Aeson ((>$<), (>/\<))
import Data.Argonaut.JSONDateTime (JSONDateTime)
import Data.Generic.Rep (class Generic)
import Data.Lens (Iso', Lens', Prism', iso, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Maybe (Maybe(..))
import Data.Newtype (class Newtype, unwrap)
import Data.Show.Generic (genericShow)
import Data.Tuple.Nested ((/\))
import Data.UUID.Argonaut (UUID)
import GenTypesDemo.Utilities.Email (Email)
import Servant.PureScript (class ToPathSegment)
import Type.Proxy (Proxy(Proxy))
import Data.Argonaut.Decode.Aeson as D
import Data.Argonaut.Encode.Aeson as E
import Data.Map as Map

newtype CreateUserRequest = CreateUserRequest
  { email :: Email
  , username :: Username
  }

instance Show CreateUserRequest where
  show a = genericShow a

derive instance Eq CreateUserRequest

instance EncodeJson CreateUserRequest where
  encodeJson = defer \_ -> E.encode $ unwrap >$< (E.record
                                                   { email: E.value :: _ Email
                                                   , username: E.value :: _ Username
                                                   })

instance DecodeJson CreateUserRequest where
  decodeJson = defer \_ -> D.decode $ (CreateUserRequest <$> D.record "CreateUserRequest"
      { email: D.value :: _ Email
      , username: D.value :: _ Username
      })

derive instance Generic CreateUserRequest _

derive instance Newtype CreateUserRequest _

--------------------------------------------------------------------------------

_CreateUserRequest :: Iso' CreateUserRequest {email :: Email, username :: Username}
_CreateUserRequest = _Newtype

--------------------------------------------------------------------------------

newtype CreatedAt = CreatedAt JSONDateTime

derive instance Eq CreatedAt

derive instance Ord CreatedAt

instance Show CreatedAt where
  show a = genericShow a

instance EncodeJson CreatedAt where
  encodeJson = defer \_ -> E.encode $ unwrap >$< E.value

instance DecodeJson CreatedAt where
  decodeJson = defer \_ -> D.decode $ (CreatedAt <$> D.value)

derive instance Generic CreatedAt _

derive instance Newtype CreatedAt _

--------------------------------------------------------------------------------

_CreatedAt :: Iso' CreatedAt JSONDateTime
_CreatedAt = _Newtype

--------------------------------------------------------------------------------

newtype Error = Error
  { error :: String
  , status :: Int
  }

derive instance Eq Error

derive instance Ord Error

instance Show Error where
  show a = genericShow a

instance EncodeJson Error where
  encodeJson = defer \_ -> E.encode $ unwrap >$< (E.record
                                                   { error: E.value :: _ String
                                                   , status: E.value :: _ Int
                                                   })

instance DecodeJson Error where
  decodeJson = defer \_ -> D.decode $ (Error <$> D.record "Error"
      { error: D.value :: _ String
      , status: D.value :: _ Int
      })

derive instance Generic Error _

derive instance Newtype Error _

--------------------------------------------------------------------------------

_Error :: Iso' Error {error :: String, status :: Int}
_Error = _Newtype

--------------------------------------------------------------------------------

newtype UpdateUserRequest = UpdateUserRequest
  { newEmail :: Maybe Email
  , newUsername :: Maybe Username
  }

instance Show UpdateUserRequest where
  show a = genericShow a

derive instance Eq UpdateUserRequest

instance EncodeJson UpdateUserRequest where
  encodeJson = defer \_ -> E.encode $ unwrap >$< (E.record
                                                   { newEmail: (E.maybe E.value) :: _ (Maybe Email)
                                                   , newUsername: (E.maybe E.value) :: _ (Maybe Username)
                                                   })

instance DecodeJson UpdateUserRequest where
  decodeJson = defer \_ -> D.decode $ (UpdateUserRequest <$> D.record "UpdateUserRequest"
      { newEmail: (D.maybe D.value) :: _ (Maybe Email)
      , newUsername: (D.maybe D.value) :: _ (Maybe Username)
      })

derive instance Generic UpdateUserRequest _

derive instance Newtype UpdateUserRequest _

--------------------------------------------------------------------------------

_UpdateUserRequest :: Iso' UpdateUserRequest {newEmail :: Maybe Email, newUsername :: Maybe Username}
_UpdateUserRequest = _Newtype

--------------------------------------------------------------------------------

newtype User = User
  { id :: UserId
  , info :: UserData
  }

instance Show User where
  show a = genericShow a

derive instance Eq User

instance EncodeJson User where
  encodeJson = defer \_ -> E.encode $ unwrap >$< (E.record
                                                   { id: E.value :: _ UserId
                                                   , info: E.value :: _ UserData
                                                   })

instance DecodeJson User where
  decodeJson = defer \_ -> D.decode $ (User <$> D.record "User"
      { id: D.value :: _ UserId
      , info: D.value :: _ UserData
      })

derive instance Generic User _

derive instance Newtype User _

--------------------------------------------------------------------------------

_User :: Iso' User {id :: UserId, info :: UserData}
_User = _Newtype

--------------------------------------------------------------------------------

newtype UserData = UserData
  { email :: Email
  , username :: Username
  , created :: CreatedAt
  }

instance Show UserData where
  show a = genericShow a

derive instance Eq UserData

instance EncodeJson UserData where
  encodeJson = defer \_ -> E.encode $ unwrap >$< (E.record
                                                   { email: E.value :: _ Email
                                                   , username: E.value :: _ Username
                                                   , created: E.value :: _ CreatedAt
                                                   })

instance DecodeJson UserData where
  decodeJson = defer \_ -> D.decode $ (UserData <$> D.record "UserData"
      { email: D.value :: _ Email
      , username: D.value :: _ Username
      , created: D.value :: _ CreatedAt
      })

derive instance Generic UserData _

derive instance Newtype UserData _

--------------------------------------------------------------------------------

_UserData :: Iso' UserData {email :: Email, username :: Username, created :: CreatedAt}
_UserData = _Newtype

--------------------------------------------------------------------------------

newtype UserId = UserId UUID

derive newtype instance ToPathSegment UserId

derive instance Eq UserId

derive instance Ord UserId

instance Show UserId where
  show a = genericShow a

instance EncodeJson UserId where
  encodeJson = defer \_ -> E.encode $ unwrap >$< E.value

instance DecodeJson UserId where
  decodeJson = defer \_ -> D.decode $ (UserId <$> D.value)

derive instance Generic UserId _

derive instance Newtype UserId _

--------------------------------------------------------------------------------

_UserId :: Iso' UserId UUID
_UserId = _Newtype

--------------------------------------------------------------------------------

newtype Username = Username String

derive instance Eq Username

derive instance Ord Username

instance Show Username where
  show a = genericShow a

instance EncodeJson Username where
  encodeJson = defer \_ -> E.encode $ unwrap >$< E.value

instance DecodeJson Username where
  decodeJson = defer \_ -> D.decode $ (Username <$> D.value)

derive instance Generic Username _

derive instance Newtype Username _

--------------------------------------------------------------------------------

_Username :: Iso' Username String
_Username = _Newtype
